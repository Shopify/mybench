package mybench

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"math/rand"
	"strings"
	"sync"
	"time"
)

// Generates integers according to the distribution given.
//
// SampleFromExisting is the same as Generate and does not actually keep track
// of existing values.
type NumberGenerator[T number] struct {
	RandomNumberDistribution[T]
}

func (g *NumberGenerator[T]) Generate(r *rand.Rand) interface{} {
	return g.GenerateTyped(r)
}

func (g *NumberGenerator[T]) GenerateTyped(r *rand.Rand) T {
	return g.RandomNumberDistribution.NextValue(r)
}

func (g *NumberGenerator[T]) SampleFromExisting(r *rand.Rand) interface{} {
	return g.SampleFromExistingTyped(r)
}

func (g *NumberGenerator[T]) SampleFromExistingTyped(r *rand.Rand) T {
	return g.RandomNumberDistribution.ExistingValue(r)
}

func NewAutoIncrementGeneratorTwo(min, current int64) *NumberGenerator[int64] {
	return &NumberGenerator[int64]{
		RandomNumberDistribution: NewAutoIncrementDistribution(min, current),
	}
}

// Generates a string with length according to a random distribution. For
// example, if a GaussianIntDistribution is passed to this generator with a
// mean of 10 and a standard deviation of 2, then most of the strings generated
// by this generator will have length between 6 - 14, according to the Gaussian
// distribution.
//
// The string generated is totally random, which means the cardinality of the
// data generated by this generator is effectively infinite. SampleFromExisting
// does not keep track of existing entries and is implemented by calling
// Generate, this means it is unlikely that it will generate an existing entry,
// making the implementation basically incorrect.
//
// If you need a string generated with bounded cardinality, use the
// BoundedCardinalityStringGenerator.
type RandomLengthStringGenerator struct {
	RandomNumberDistribution[int64]
}

func (g *RandomLengthStringGenerator) Generate(r *rand.Rand) interface{} {
	return g.GenerateTyped(r)
}

func (g *RandomLengthStringGenerator) GenerateTyped(r *rand.Rand) string {
	n := g.RandomNumberDistribution.NextValue(r)

	buf := make([]byte, n)
	for i := range buf {
		buf[i] = characters[r.Intn(len(characters))]
	}

	return string(buf)
}

func (g *RandomLengthStringGenerator) SampleFromExisting(r *rand.Rand) interface{} {
	return g.SampleFromExistingTyped(r)
}

func (g *RandomLengthStringGenerator) SampleFromExistingTyped(r *rand.Rand) string {
	return g.GenerateTyped(r)
}

// Generates a length based on an integer generated by the underlying
// RandomNumberDistribution. Each integer in the distribution generates a
// single unique string with length specified in the Length field. The
// generation is performed by hashing the integer (converted to a string). This
// hash value is then extended or truncated to the length specified.
//
// SampleFromExisting does not keep track of values already generated but will
// generate according to the distribution given. This means it will likely
// generate a value that exists if the cardinality is small enough and the
// number of values generated is large.
//
// For example, if an uniform integer distribution between 1 to 10 is given to
// this generator, the generate will generate 10 unique string values with
// uniform probability. If a Gaussian distribution is given with mean of 10 and
// standard deviation of 2, then most of the time, the generator will generate
// 9 unique string values (95% of the time the integers will fall between 6 and
// 14, which means 9 string values).
//
// Another way to use this generator is via the AutoIncrementDistribution,
// which allows you to theoretically generate unique strings (subject to
// collision risk of MD5, which we may consider fixing).
type BoundedCardinalityStringGeneratorTwo struct {
	RandomNumberDistribution[int64]
	Length int
}

func (g *BoundedCardinalityStringGeneratorTwo) Generate(r *rand.Rand) interface{} {
	return g.GenerateTyped(r)
}

func (g *BoundedCardinalityStringGeneratorTwo) GenerateTyped(r *rand.Rand) string {
	n := g.RandomNumberDistribution.NextValue(r)
	return generateUniqueStringFromIntTwo(n, g.Length)
}

func (g *BoundedCardinalityStringGeneratorTwo) SampleFromExisting(r *rand.Rand) interface{} {
	return g.SampleFromExistingTyped(r)
}

func (g *BoundedCardinalityStringGeneratorTwo) SampleFromExistingTyped(r *rand.Rand) string {
	return g.GenerateTyped(r)
}

// Generates values from a discrete set of possible values.
//
// Sample from existing is the exact same as generation, which means it is
// possible to generate values not in the database but available in the set of
// values, if some values have not been inserted into the database.
type EnumGenerator[T any] struct {
	values []T
}

func NewEnumGenerator[T any](values []T) *EnumGenerator[T] {
	return &EnumGenerator[T]{
		values: values,
	}
}

func (g *EnumGenerator[T]) Generate(r *rand.Rand) interface{} {
	return g.GenerateTyped(r)
}

func (g *EnumGenerator[T]) SampleFromExisting(r *rand.Rand) interface{} {
	return g.SampleFromExistingTyped(r)
}

func (g *EnumGenerator[T]) GenerateTyped(r *rand.Rand) T {
	return g.values[r.Intn(len(g.values))]
}

func (g *EnumGenerator[T]) SampleFromExistingTyped(r *rand.Rand) T {
	return g.GenerateTyped(r)
}

type DatetimeInterval struct {
	Start time.Time
	End   time.Time
}

func (d DatetimeInterval) Duration() time.Duration {
	return d.Start.Sub(d.End)
}

// Generates a date time value in two modes:
//
//  1. GenerateNow == true will cause Generate to return time.Now.
//  2. GenerateNow == false will cause Generate to generate a random time
//     between the intervals specified in Intervals with uniform probability
//     distribution.
//
// SampleFromExisting always will sample from the Intervals. However, if
// GenerateNow == true, then it will also sample between an extra interval
// between when Generate() is first called and the moment the
// SampleFromExisting call is made.
//
// Generate and SampleFromExisting will return a string of the time formatted
// with YYYY-MM-DD hh:mm:ss, which is what SQL expects. GenerateTyped and
// SampleFromExistingTyped will return time.Time.
type UniformDatetimeGenerator struct {
	// Intervals where a datetime value will be randomly generated according to
	// an uniform distribution. SampleFromExisting will always generate values
	// with these intervals. Generate will use these intervals unless GenerateNow
	// is true. In that case, Generate will
	Intervals []DatetimeInterval

	// Generate will always return Now instead of sampling from the Intervals
	// specified. SampleFromExisting will still sample from the Intervals above,
	// although an interval between when the generator is first used and now will
	// be added to the SampleFromExisting.
	GenerateNow bool

	// Need a once object to ensure that the call to initialize firstGenerateTime
	// happens once in a thread-safe way.
	//
	// Note, sync.Once is fast (using atomic and mutex only at the beginning), so
	// it shouldn't slowdown the generator.
	firstGenerateOnce sync.Once
	firstGenerateTime time.Time
}

func (g *UniformDatetimeGenerator) Generate(r *rand.Rand) interface{} {
	return g.GenerateTyped(r).Format("2006-01-02 15:04:05")
}

func (g *UniformDatetimeGenerator) GenerateTyped(r *rand.Rand) time.Time {
	if g.GenerateNow {
		g.firstGenerateOnce.Do(func() {
			g.firstGenerateTime = time.Now()
		})

		return time.Now()
	}

	return g.SampleFromExistingTyped(r)
}

func (g *UniformDatetimeGenerator) SampleFromExisting(r *rand.Rand) interface{} {
	return g.SampleFromExistingTyped(r).Format("2006-01-02 15:04:05")
}

func (g *UniformDatetimeGenerator) SampleFromExistingTyped(r *rand.Rand) time.Time {
	// Need to find a random interval first, and take into consideration of first
	// generate time if GenerateNow is enabled (which effectively forms another
	// interval).
	idx := r.Intn(len(g.Intervals) + 1)
	var randomInterval DatetimeInterval
	if idx == len(g.Intervals) {
		randomInterval = DatetimeInterval{Start: g.firstGenerateTime, End: time.Now()}
	} else {
		randomInterval = g.Intervals[idx]
	}

	randomDurationSeconds := r.Float64() * randomInterval.Duration().Seconds()
	randomDuration := time.Duration(randomDurationSeconds) * time.Second

	return randomInterval.Start.Add(randomDuration)
}

func generateUniqueStringFromIntTwo(n int64, length int) string {
	hash := md5.Sum([]byte(fmt.Sprintf("%d", n)))
	hashStr := hex.EncodeToString(hash[:])
	if length == len(hashStr) {
		return hashStr
	}

	if length < len(hashStr) {
		return hashStr[:length]
	}

	// If the required length is bigger than the hash length, then we need to
	// extend the hash. The idea is to repeat the hash separated with -.
	var extendedHashBuf strings.Builder
	extendedHashBuf.WriteString(hashStr)

	for extendedHashBuf.Len() < length {
		extendedHashBuf.WriteByte('-')
		extendedHashBuf.WriteString(hashStr)
	}

	// If the repeated hash is longer than the required length, we truncate it
	// once again.
	return extendedHashBuf.String()[:length]
}
